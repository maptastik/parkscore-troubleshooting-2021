import{bW as e,g as t,e as r,i as s,eb as i,gk as o,r as a,J as n,X as c,dI as l,bk as d,q as h,k as m,c4 as u,iZ as g}from"./vendor.1ee57f36.js";import{n as p}from"./shapingUtils.66b0bc31.js";import{s as y,m as f,t as _,L as b}from"./WGLMeshFactory.b3d89ebf.js";import{C as j}from"./ComputedAttributeStorage.637c93e6.js";import{p as S}from"./BaseProcessor.d17d36c2.js";import"./BidiEngine.39026c84.js";import"./MD5.89293f8b.js";import"./Utils.88967ee0.js";import"./MaterialKey.464cac5a.js";import"./visualVariablesUtils.dc4022b6.js";import"./Rect.8611b8cd.js";import"./index.4894e768.js";import"./cimAnalyzer.a961a551.js";import"./quantizationUtils.66d2dc60.js";import"./CIMSymbolHelper.2ecfa4b9.js";import"./VertexBuffer.19222be6.js";import"./CircularArray.1d7faf48.js";import"./TurboLine.6302d753.js";import"./GeometryUtils.4f6b8486.js";import"./rbush.d43ba1fa.js";import"./json.9d10e1a3.js";import"./quickselect.53c6798b.js";import"./FeatureSetReader.3ec5c3db.js";import"./centroid.b04b550b.js";class k{constructor(t,r=2){this._bucketSize=t,this._rowsLength=e/t,this._colsLength=e/t,this._elementsPerBucket=r,this._grid=this._initGrid()}checkOverlap(e,t){const r=Math.floor(e/this._bucketSize),s=Math.floor(t/this._bucketSize);return r<0||r>=this._rowsLength||s<0||s>=this._colsLength||this._grid[s*this._colsLength+r]>=this._elementsPerBucket}markUsed(e,t){const r=Math.floor(e/this._bucketSize),s=Math.floor(t/this._bucketSize);this._grid[s*this._colsLength+r]+=1}reset(){this._grid=this._initGrid()}_initGrid(){return new Uint8Array(this._rowsLength*this._colsLength)}}t.getLogger("esri.views.2d.layers.features.processors.SymbolProcessor");let v=class extends S{constructor(){super(...arguments),this.type="symbol"}destroy(){}get supportsTileUpdates(){return!0}async update(e,t){const r=t.schema.processors[0];if("symbol"!==r.type)return;const s=i(this._schema,r);o(s,"mesh")&&(a("esri-2d-update-debug")&&console.debug("Applying Update - Processor:",s),e.mesh=!0,e.why.mesh.push("Symbology changed"),this._schema=r,this._factory=this._createFactory(r),this._factory.update(r,this.tileStore.tileScheme.tileInfo))}onTileData(e,t,r){return n(r),this._onTileData(e,t,r)}onTileError(e,t,r){const s=r.signal,i={tileKey:e.id,error:t};return this.remoteClient.invoke("tileRenderer.onTileError",i,{signal:s})}_createFactory(e){const{geometryType:t,objectIdField:r,fields:s}=this.service,i={geometryType:t,fields:s,spatialReference:c.fromJSON(this.spatialReference)},o=new b(((e,t)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",e,t)),!1);return this._store=o,this._matcher=y(e.mesh.matcher,o,i),new f(t,r,o)}async _onTileData(e,t,r){const{type:s,addOrUpdate:i,remove:o,end:a}=t;if(!i){const t={type:s,addOrUpdate:null,remove:o,clear:!1,end:a};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:t},r)}const c=this._processFeatures(e,i,r),h=r.signal;try{const t=await c,r=l(t,(e=>e.message)),i=l(t,(e=>e.transferList))||[],m={type:s,addOrUpdate:r,remove:o,clear:!1,end:a},u={transferList:d(i)||[],signal:h};return n(u),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:m},u)}catch(m){this._handleError(e,m,r)}}async _processFeatures(e,t,r){if(h(t)||!t.hasFeatures)return null;const s={transform:e.transform,hasZ:!1,hasM:!1},i=this._factory,o={viewingMode:"",scale:e.scale},a=await this._matcher;n(r);const c=this._getLabelInfos(e,t);return await i.analyze(t.getCursor(),a,s,o),n(r),this._writeFeatureSet(e,t,s,c,i)}_writeFeatureSet(e,t,r,s,i){const o=i.createMeshData(t.getApproximateSize()),a={viewingMode:"",scale:e.scale},n=t.getCursor();for(;n.next();)try{const t=n.getDisplayId(),c=m(s)?s.get(t):null;i.writeCursor(o,n,r,a,e.level,c)}catch(c){}return this._encodeDisplayData(o)}_encodeDisplayData(e){const t={},r=new Array;return e.encode(t,r),{message:t,transferList:r}}_handleError(e,t,r){if(!u(t)){const s={tileKey:e.id,error:t.message};return this.remoteClient.invoke("tileRenderer.onTileError",s,{signal:r.signal})}}_shouldDiscard(e,t){switch(this.service.geometryType){case"esriGeometryPoint":{const r=t.readLegacyPointGeometry();return!r||e.checkOverlap(r.x,r.y)}case"esriGeometryPolygon":{const r=t.readLegacyCentroid();return!r||e.checkOverlap(r.x,r.y)}default:return!1}}_markUsed(e,t){switch(this.service.geometryType){case"esriGeometryPoint":{const{x:r,y:s}=t.readLegacyPointGeometry();return e.markUsed(r,s)}case"esriGeometryPolygon":{const{x:r,y:s}=t.readLegacyCentroid();return e.markUsed(r,s)}}}_getLabelInfos(e,t){const r=this._schema.mesh.labels,s=l(r,(t=>t.filter((t=>{return r=t,s=e.scale,(!r.minScale||r.minScale>=s)&&(!r.maxScale||r.maxScale<=s);var r,s}))));if(h(s)||0===s.length)return null;const i=new Map,o=new k(g),a=t.getCursor();for(;a.next();){const e=a.getDisplayId();if(this._shouldDiscard(o,a)){i.has(e)||i.set(e,null);continue}let t=!1;const r=[],n=j(e),c=n&&1!==a.readAttribute("cluster_count")?"aggregate":"feature";for(const i of s){if(i.target!==c)continue;const s=a.getStorage(),o=n&&"feature"===c?s.getComputedStringAtIndex(a.readAttribute("referenceId"),i.fieldIndex):s.getComputedStringAtIndex(e,i.fieldIndex);if(!o)continue;const l=p(o.toString()),d=l[0],h=l[1];this._store.getMosaicItem(i.symbol,_(d)).then((e=>{r[i.index]={glyphs:e.glyphMosaicItems,rtl:h,index:i.index}})),t=!0}i.set(e,r),t&&this._markUsed(o,a)}return i}};v=r([s("esri.views.2d.layers.features.processors.SymbolProcessor")],v);var w=v;export default w;
