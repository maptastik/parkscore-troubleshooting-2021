var e=Object.defineProperty,t=Object.prototype.hasOwnProperty,i=Object.getOwnPropertySymbols,s=Object.prototype.propertyIsEnumerable,n=(t,i,s)=>i in t?e(t,i,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[i]=s,r=(e,r)=>{for(var a in r||(r={}))t.call(r,a)&&n(e,a,r[a]);if(i)for(var a of i(r))s.call(r,a)&&n(e,a,r[a]);return e};import{ai as a,gt as o,m as l,gZ as d,g_ as u,_ as p,dq as y,dL as c,e7 as f,aZ as m,cM as h,e4 as g,e6 as b,g$ as I}from"./vendor.1ee57f36.js";import{g as j,f as F}from"./rbush.d43ba1fa.js";import{h as _,w as E,b as T}from"./geojson.9fd51f9d.js";import{i as q,u as x,s as w}from"./clientSideDefaults.0a3bb9c5.js";import{h as O}from"./FeatureStore.2b388c50.js";import{b as D}from"./QueryEngine.853abea2.js";import{y as R,d as v,c as S,u as k,h as Q}from"./sourceUtils.b0636dc2.js";import"./json.9d10e1a3.js";import"./quickselect.53c6798b.js";import"./aaBoundingBox.960884d4.js";import"./centroid.b04b550b.js";import"./index.4894e768.js";import"./WhereClause.4830c95f.js";import"./timeSupport.20e3d0fa.js";import"./quantizationUtils.66d2dc60.js";const Z={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};export default class{constructor(){this._queryEngine=null}destroy(){this._queryEngine&&this._queryEngine&&this._queryEngine.destroy(),this._queryEngine=this._requiredFields=this._fieldsIndex=this._createDefaultAttributes=null}async load(e){const t=[];await this._checkProjection(e.spatialReference);let i=null;e.url&&(i=(await a(e.url,{responseType:"json"})).data,await _(i));const s=E(i,{geometryType:e.geometryType}),n=e.fields||s.fields||[],m=null!=e.hasZ?e.hasZ:s.hasZ,h=s.geometryType,g=e.objectIdField||("number"===s.objectIdFieldType?s.objectIdFieldName:"OBJECTID")||"OBJECTID",b=e.spatialReference||o;let I=e.timeInfo;if(!h)throw new l("geojson-layer:missing-property","geometryType not set and couldn't be inferred from the provided features");if("string"===s.objectIdFieldType&&t.push({name:"geojson-layer:unsupported-id-type",message:"Feature ids are of type string and can't be honored."}),n===s.fields&&s.unknownFields.length>0&&t.push({name:"geojson-layer:unknown-field-types",message:"Some fields types couldn't be inferred from the features and were dropped",details:{unknownFields:s.unknownFields}}),g){let e=null;n.some((t=>t.name===g&&(e=t,!0)))?(e.type="esriFieldTypeOID",e.editable=!1,e.nullable=!1):n.unshift({alias:g,name:g,type:"esriFieldTypeOID",editable:!1,nullable:!1})}for(const r of n){if(null==r.name&&(r.name=r.alias),null==r.alias&&(r.alias=r.name),!r.name)throw new l("geojson-layer:invalid-field-name","field name is missing",{field:r});if(r.name===g&&(r.type="esriFieldTypeOID"),-1===d.jsonValues.indexOf(r.type))throw new l("geojson-layer:invalid-field-type",`invalid type for field "${r.name}"`,{field:r})}const F={};this._requiredFields=[];for(const r of n)if("esriFieldTypeOID"!==r.type&&"esriFieldTypeGlobalID"!==r.type){r.editable=null==r.editable||!!r.editable,r.nullable=null==r.nullable||!!r.nullable;const e=u(r);r.nullable||void 0!==e?F[r.name]=e:this._requiredFields.push(r)}if(this._fieldsIndex=new p(n),I){if(I.startTimeField){const e=this._fieldsIndex.get(I.startTimeField);e?(I.startTimeField=e.name,e.type="esriFieldTypeDate"):I.startTimeField=null}if(I.endTimeField){const e=this._fieldsIndex.get(I.endTimeField);e?(I.endTimeField=e.name,e.type="esriFieldTypeDate"):I.endTimeField=null}if(I.trackIdField){const e=this._fieldsIndex.get(I.trackIdField);e?I.trackIdField=e.name:(I.trackIdField=null,t.push({name:"geojson-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:I}}))}I.startTimeField||I.endTimeField||(t.push({name:"geojson-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing",details:{timeInfo:I}}),I=null)}const R={warnings:t,featureErrors:[],layerDefinition:r(r({},Z),{drawingInfo:q(h),templates:x(F),extent:null,geometryType:h,objectIdField:g,fields:n,hasZ:!!m,timeInfo:I})};this._queryEngine=new D({fields:n,geometryType:h,hasM:!1,hasZ:m,objectIdField:g,spatialReference:b,timeInfo:I,featureStore:new O({geometryType:h,hasM:!1,hasZ:m})}),this._createDefaultAttributes=w(F,g),this._nextObjectId=s.maxObjectId+1;const v=T(i,{geometryType:h,hasZ:m,objectIdFieldName:"number"===s.objectIdFieldType?g:null});if(!y(b,o))for(const r of v)r.geometry&&(r.geometry=c(j(f(r.geometry,h,m,!1),o,b)));return this._loadInitialFeatures(R,v),R}async applyEdits(e){const{spatialReference:t,geometryType:i}=this._queryEngine;return await m([R(t,i),F(e.adds,t),F(e.updates,t)]),this._applyEdits(e)}async queryFeatures(e={},t={}){return this._queryEngine.executeQuery(e,t.signal)}async queryFeatureCount(e={},t={}){return this._queryEngine.executeQueryForCount(e,t.signal)}async queryObjectIds(e={},t={}){return this._queryEngine.executeQueryForIds(e,t.signal)}async queryExtent(e={},t={}){return this._queryEngine.executeQueryForExtent(e,t.signal)}_loadInitialFeatures(e,t){const{featureStore:i,objectIdField:s}=this._queryEngine,n=[];for(const r of t){const t=this._createDefaultAttributes(),i=v(this._fieldsIndex,this._requiredFields,t,r.attributes,!0,e.warnings);i?e.featureErrors.push(i):(this._assignObjectId(t,r.attributes,!0),r.attributes=t,r.objectId=t[s],n.push(r))}if(i.addMany(n),e.layerDefinition.extent=this._queryEngine.fullExtent,e.layerDefinition.timeInfo){const{start:t,end:i}=this._queryEngine.timeExtent;e.layerDefinition.timeInfo.timeExtent=[t,i]}return e}_applyEdits(e){const{adds:t,updates:i,deletes:s}=e,n={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(t&&t.length&&this._applyAddEdits(n,t),i&&i.length&&this._applyUpdateEdits(n,i),s&&s.length){for(const e of s)n.deleteResults.push(S(e));this._queryEngine.featureStore.removeManyById(s)}return{fullExtent:this._queryEngine.fullExtent,timeExtent:this._queryEngine.timeExtent,featureEditResults:n}}_applyAddEdits(e,t){const{addResults:i}=e,{geometryType:s,hasM:n,hasZ:r,objectIdField:a,spatialReference:o,featureStore:l}=this._queryEngine,d=[];for(const u of t){if(u.geometry&&s!==h(u.geometry)){i.push(k("Incorrect geometry type."));continue}const t=this._createDefaultAttributes(),n=v(this._fieldsIndex,this._requiredFields,t,u.attributes);if(n)i.push(n);else{if(this._assignObjectId(t,u.attributes),u.attributes=t,null!=u.uid){const t=u.attributes[a];e.uidToObjectId[u.uid]=t}u.geometry&&(u.geometry=j(Q(u.geometry,o),u.geometry.spatialReference,o)),d.push(u),i.push(S(u.attributes[a]))}}l.addMany(g([],d,s,r,n,a))}_applyUpdateEdits({updateResults:e},t){const{geometryType:i,hasM:s,hasZ:n,objectIdField:r,spatialReference:a,featureStore:o}=this._queryEngine;for(const l of t){const{attributes:t,geometry:d}=l,u=t&&t[r];if(null==u){e.push(k(`Identifier field ${r} missing`));continue}if(!o.has(u)){e.push(k(`Feature with object id ${u} missing`));continue}const p=b(o.getFeature(u),i,n,s);if(d){if(i!==h(d)){e.push(k("Incorrect geometry type."));continue}p.geometry=j(Q(d,a),d.spatialReference,a)}if(t){const i=v(this._fieldsIndex,this._requiredFields,p.attributes,t);if(i){e.push(i);continue}}o.add(I(p,i,n,s,r)),e.push(S(u))}}_assignObjectId(e,t,i=!1){const s=this._queryEngine.objectIdField;i&&isFinite(t[s])?e[s]=t[s]:e[s]=this._nextObjectId++}async _checkProjection(e){try{await F(o,e)}catch(t){throw new l("geojson-layer","Projection not supported")}}}
