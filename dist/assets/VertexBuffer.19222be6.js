import{C as t,b as e}from"./Utils.88967ee0.js";import{g as s,dw as i,bX as r,eF as o,bW as h}from"./vendor.1ee57f36.js";import{e as n}from"./shapingUtils.66b0bc31.js";class a{constructor(){this.vertexData=new Map,this.vertexCount=0,this.indexData=[]}clear(){this.vertexData.clear(),this.vertexCount=0,this.indexData=[]}update(t,e,s){for(const i in t)this.vertexData.set(i,t[i]);for(const i in this.vertexData)null===t[i]&&this.vertexData.delete(i);this.vertexCount=e,this.indexData=s}}class u{constructor(t,e,s,i=0,r=0){this.id=t,this.geometryType=e,this.materialKey=s,this.minZoom=i,this.maxZoom=r,this.meshData=null,this.symbolLevel=0,this.zOrder=0,this.vertexFrom=0,this.vertexCount=0,this.indexFrom=0,this.indexCount=0}get sortKey(){return void 0===this._sortKey&&this._computeSortKey(),this._sortKey}clone(){return this.copy()}copy(){const t=new u(this.id,this.geometryType,this.materialKey);return t.vertexFrom=this.vertexFrom,t.vertexCount=this.vertexCount,t.indexFrom=this.indexFrom,t.indexCount=this.indexCount,t.zOrder=this.zOrder,t.symbolLevel=this.symbolLevel,t.meshData=this.meshData,t.minZoom=this.minZoom,t.maxZoom=this.maxZoom,t}setMeshDataFromBuffers(e,s,i){const r=new a;for(const o in s){const i=s[o].stride,h=s[o].data,n=[],a=t(i);for(let t=0;t<i*e.vertexCount/a;++t)n[t]=h[t+i*e.vertexFrom/a];r.vertexData.set(o,n)}r.indexData.length=0;for(let t=0;t<e.indexCount;++t)r.indexData[t]=i[t+e.indexFrom]-e.vertexFrom;r.vertexCount=e.vertexCount,this.meshData=r}readMeshDataFromBuffers(e,s){this.meshData?this.meshData.clear():this.meshData=new a;for(const i in e){const s=e[i].stride,r=e[i].data,o=[],h=t(s);for(let t=0;t<s*this.vertexCount/h;++t)o[t]=r[t+s*this.vertexFrom/h];this.meshData.vertexData.set(i,o)}this.meshData.indexData.length=0;for(let t=0;t<this.indexCount;++t)this.meshData.indexData[t]=s[t+this.indexFrom]-this.vertexFrom;this.meshData.vertexCount=this.vertexCount}writeMeshDataToBuffers(e,s,i,r){for(const o in s){const i=s[o].stride,r=this.meshData.vertexData.get(o),h=s[o].data,n=t(i);for(let t=0;t<i*this.meshData.vertexCount/n;++t)h[t+i*e/n]=r[t]}for(let t=0;t<this.meshData.indexData.length;++t)r[t+i]=this.meshData.indexData[t]+e;this.vertexFrom=e,this.vertexCount=this.meshData.vertexCount,this.indexFrom=i,this.indexCount=this.meshData.indexData.length}static writeAllMeshDataToBuffers(t,e,s){let i=0,r=0;for(const o of t)o.writeMeshDataToBuffers(i,e,r,s),i+=o.vertexCount,r+=o.indexCount}_computeSortKey(){this._sortKey=(31&this.symbolLevel)<<12|(127&this.zOrder)<<4|7&this.geometryType}serialize(t){return t.push(this.geometryType),t.push(this.materialKey),t.push(this.vertexFrom),t.push(this.vertexCount),t.push(this.indexFrom),t.push(this.indexCount),t.push(this.minZoom),t.push(this.maxZoom),t}static deserialize(t,e){const s=t.readInt32(),i=t.readInt32(),r=new u(e.id,s,i);return r.vertexFrom=t.readInt32(),r.vertexCount=t.readInt32(),r.indexFrom=t.readInt32(),r.indexCount=t.readInt32(),r.minZoom=t.readInt32(),r.maxZoom=t.readInt32(),r}}function c(t,e){if(null!==e){t.push(e.length);for(const s of e)s.serialize(t);return t}t.push(0)}function f(t,e,s){const i=t.readInt32(),r=new Array(i);for(let o=0;o<r.length;o++)r[o]=e.deserialize(t,s);return r}const d=s.getLogger("esri/views/2d/engine/webgl/collisions/Metric");class l{constructor(t,e,s,r,o){this.id=t,this.range=e,this.boxes=null,this.minZoom=-1,this.size=0,this.directionX=0,this.directionY=0,this.offsetX=0,this.offsetY=0,this.placementPadding=0,this.anchor=i(s,r),this.baseZoom=o}add(t,e,s){t.x=t.x+e,t.y=t.y+s,this.bounds?this.boxes?(this.boxes.push(t),this.bounds.extend(t)):(this.boxes=[this.bounds,t],this.bounds=this.bounds.clone(),this.bounds.extend(t)):this.bounds=t}computeIndex(){const t=this.anchor[0],e=this.anchor[1],s=Math.floor(t/r),i=Math.floor(e/r);this.xBucket=s,this.yBucket=i;const o=h/r;if(this.hasVV)return this.xOverflow=o,void(this.yOverflow=o);this.xOverflow=Math.min(o,Math.ceil(2*this.bounds.width/r)),this.yOverflow=Math.min(o,Math.ceil(2*this.bounds.height/r))}findCollisionDelta(t){const e=this.bounds.findCollisionDelta(t.bounds),s=this.boxes&&this.boxes.length,i=t.boxes&&t.boxes.length;return Math.abs(e)>o||!s&&!i?e:s&&i?this._boxesToBoxes(t):s?this._boxesToBox(t):this._boxToBoxes(t)}computeVVOffset(t,e){e||d.error("mapview-labeling",`Unable to compute label offset. Expected an evaluator function but found ${e}`);let s=this.size;if(this.hasVV){const i=e(t);s=isNaN(i)||null==i||i===1/0?this.size:i}this._computeOffset(s)}setPlacementOffset(t,e,s,i,r){this.hasVV=t,this.size=e,this.placementPadding=Math.round(s),this.directionX=i,this.directionY=r}clone(){const t=new l(this.id,this.range,this.anchor[0],this.anchor[1],this.baseZoom);return t.minZoom=this.minZoom,this.bounds&&(t.bounds=this.bounds.clone()),this.boxes&&(t.boxes=this.boxes.map((t=>t.clone()))),t.xBucket=this.xBucket,t.yBucket=this.yBucket,t.xOverflow=this.xOverflow,t.yOverflow=this.yOverflow,t.hasVV=this.hasVV,t.size=this.size,t.directionX=this.directionX,t.directionY=this.directionY,t.offsetX=this.offsetX,t.offsetY=this.offsetY,t}_boxToBoxes(t){let e=-1/0;for(const s of t.boxes){const t=this.bounds.findCollisionDelta(s);e=Math.max(t,e)}return e}_boxesToBox(t){let e=this.boxes[0].findCollisionDelta(t.bounds);for(let s=1;s<this.boxes.length;s++){const i=this.boxes[s].findCollisionDelta(t.bounds);e=Math.max(i,e)}return e}_boxesToBoxes(t){let e=-1/0;for(let s=0;s<this.boxes.length;s++){const i=this.boxes[s];for(const s of t.boxes){const t=i.findCollisionDelta(s);e=Math.max(t,e)}}return e}_computeOffset(t){this.offsetX=this.directionX*(t/2+this.placementPadding),this.offsetY=this.directionY*(t/2+this.placementPadding)}serialize(t){return t.push(this.id),this.bounds.serialize(t),t.push(this.range.from),t.push(this.range.count),t.push(this.anchor[0]),t.push(this.anchor[1]),t.push(this.baseZoom),t.push(this.hasVV?1:0),t.push(this.size),t.writeF32(this.directionX),t.writeF32(this.directionY),t.push(this.offsetX),t.push(this.offsetY),t.push(this.placementPadding),c(t,this.boxes),t}static deserialize(t){const e=t.readInt32(),s=n.deserialize(t),i={from:t.readInt32(),count:t.readInt32()},r=t.readInt32(),o=t.readInt32(),h=t.readInt32(),a=t.readInt32(),u=t.readInt32(),c=t.readF32(),d=t.readF32(),p=t.readInt32(),b=t.readInt32(),x=t.readInt32(),_=f(t,n),m=new l(e,i,r,o,h);return m.bounds=s,m.boxes=_,m.setPlacementOffset(!!a,u,x,c,d),m.offsetX=p,m.offsetY=b,m.computeIndex(),a||m._computeOffset(u),m}}class p{constructor(t){this.insertAfter=null,this.id=t,this.displayRecords=[],this.metrics=[]}copy(){const t=new p(this.id);return t.set(this),t}clone(){const t=new p(this.id);return t.displayRecords=this.displayRecords.map((t=>t.clone())),t.metrics=this.metrics.map((t=>t.clone())),t.insertAfter=this.insertAfter,t}set(t){this.id=t.id,this.displayRecords=t.displayRecords,this.metrics=t.metrics,this.insertAfter=t.insertAfter}serialize(t){return t.push(this.id),c(t,this.metrics),c(t,this.displayRecords),t}static deserialize(t){const e=t.readInt32(),s=new p(e),i={id:e},r=f(t,l);return r.length&&(s.metrics=r),s.displayRecords=f(t,u,i),s}}class b{constructor(t,e){this._pos=0;const s=e?this._roundToNearest(e,t.BYTES_PER_ELEMENT):40;this._array=new ArrayBuffer(s),this._buffer=new t(this._array),this._ctor=t}get length(){return this._pos}_roundToNearest(t,e){const s=Math.round(t);return s+(e-s%e)}_ensureSize(t){if(this._pos+t>=this._buffer.length){const e=this._roundToNearest(1.5*(this._array.byteLength+t*this._buffer.BYTES_PER_ELEMENT),this._buffer.BYTES_PER_ELEMENT),s=new ArrayBuffer(e),i=new this._ctor(s);i.set(this._buffer,0),this._array=s,this._buffer=i}}writeF32(t){this._ensureSize(1);const e=this._pos;return new Float32Array(this._array,4*this._pos,1)[0]=t,this._pos++,e}push(t){this._ensureSize(1);const e=this._pos;return this._buffer[this._pos++]=t,e}writeFixed(t){this._buffer[this._pos++]=t}setValue(t,e){this._buffer[t]=e}getValue(t){return this._buffer[t]}incr(t){this._buffer[t]++}decr(t){this._buffer[t]--}writeRegion(t){this._ensureSize(t.length);const e=this._pos;return this._buffer.set(t,this._pos),this._pos+=t.length,e}buffer(){const t=this._array.slice(0,4*this._pos);return this.destroy(),t}toArray(){const t=this._array,e=[];for(let s=0;s<t.byteLength/4;s++)e.push(t[s]);return e}seek(t){this._pos=t}destroy(){this._array=null,this._buffer=null}}class x{constructor(t){this._pos=0,this._buffer=t,this._i32View=new Int32Array(this._buffer),this._f32View=new Float32Array(this._buffer)}readInt32(){return this._i32View[this._pos++]}readF32(){return this._f32View[this._pos++]}}class _{constructor(t,e){this.vertexVectorsMap=t,this._currentIndex=-1,this._currentRecordOffset=0,this._currentMetricOffset=0,this._currentMetrics=[];const s=4*(4*e.features+1),i=4*(8*e.records+1),r=4*(20*e.metrics+1);this._bufDisplayObjects=new b(Uint32Array,s+4),this._bufDisplayRecords=new b(Uint32Array,i+4),this._bufMetrics=new b(Uint32Array,r+4),this._bufDisplayObjects.push(0),this._bufDisplayRecords.push(0),this._bufMetrics.push(0)}get vertexBuffersMap(){if(!this._vertexBuffersMap){this._vertexBuffersMap={};for(let t=0;t<this.vertexVectorsMap.length;t++)this._vertexBuffersMap[t]=this.vertexVectorsMap[t].intoBuffers();this.vertexVectorsMap=null}return this._vertexBuffersMap}get(t){return this.vertexVectorsMap[t]}currentDisplayRecordCount(){return this._bufDisplayRecords[this._currentRecordOffset]}writeDisplayObject(t,e){this._bufDisplayObjects.incr(0),this._currentIndex=this._bufDisplayObjects.push(t),this._bufDisplayObjects.push(e),this._bufDisplayObjects.push(0),this._bufDisplayObjects.push(0),this._currentRecordOffset=0,this._currentMetricOffset=0,this._currentMetrics=[]}hasDisplayRecords(){return!(0===this._currentRecordOffset)}endDisplayObject(){this.hasDisplayRecords()?this._currentMetrics&&(0===this._currentMetricOffset&&(this._bufDisplayObjects.setValue(this._currentIndex+3,this._bufMetrics.length),this._currentMetricOffset=this._bufMetrics.length),c(this._bufMetrics,this._currentMetrics)):this._rollbackDisplayObject()}writeDisplayRecord(t,e,s,i,r,o,h=0,n=0){0===this._currentRecordOffset&&(this._currentRecordOffset=this._bufDisplayRecords.push(0),this._bufDisplayObjects.setValue(this._currentIndex+2,this._currentRecordOffset)),this._bufDisplayRecords.incr(this._currentRecordOffset),this._bufDisplayRecords.push(t),this._bufDisplayRecords.push(e),this._bufDisplayRecords.push(s),this._bufDisplayRecords.push(i),this._bufDisplayRecords.push(r),this._bufDisplayRecords.push(o),this._bufDisplayRecords.push(h),this._bufDisplayRecords.push(n)}writeMetrics(t){t&&this._currentMetrics.push(...t)}static deserializeDisplayObjects(t){const{bufDisplayObjects:e,bufMetrics:s,bufRecords:i}=t,r=new x(e),o=new x(i),h=new x(s),n=[];let a=r.readInt32();for(o.readInt32(),h.readInt32();a--;){const t=r.readInt32(),e=r.readInt32(),s=r.readInt32(),i=r.readInt32(),a=new p(t);0!==e&&(a.insertAfter=e),0!==s&&(a.displayRecords=f(o,u,{id:t})),0!==i&&(a.metrics=f(h,l)),n.push(a)}return n}encode(t,e){const s={};for(let i=0;i<this.vertexVectorsMap.length;i++){const t=this.vertexVectorsMap[i];s[i]={},t.transfer(s[i],e)}t.bufDisplayObjects=this._bufDisplayObjects.buffer(),t.bufRecords=this._bufDisplayRecords.buffer(),t.bufMetrics=this._bufMetrics.buffer(),e.push(t.bufDisplayObjects),e.push(t.bufMetrics),e.push(t.bufRecords),t.vertexBuffersMap=s,this.destroy()}destroy(){this.vertexVectorsMap=null,this._bufDisplayObjects=null,this._bufDisplayRecords=null,this._bufMetrics=null}_rollbackDisplayObject(){this._bufDisplayObjects.decr(0),this._bufDisplayObjects.seek(this._bufDisplayObjects.length-4),this._currentIndex=this._bufDisplayObjects.length}}class m{constructor(t,e,s){this.data=t,this.stride=e,this.vertexCount=s}static decode(t){const s=e(t.data,t.stride),i=t.stride,r=t.vertexCount;return new m(s,i,r)}static fromVertexVector(t){const s=e(t.data.buffer(),t.stride),i=t.stride,r=t.vertexCount;return new m(s,i,r)}}class y{constructor(t,e,s){this.geometryType=t,this.indexBuffer=new Uint32Array(e),this.namedBuffers=s}static decode(t){const e=t.geometryType,s=t.indexBuffer,i={};for(const r in t.namedBuffers)i[r]=m.decode(t.namedBuffers[r]);return new y(e,s,i)}static fromVertexVectors(t){const e=t.geometryType,s=t.indexVector.buffer(),i={};for(const r in t.namedVectors)i[r]=m.fromVertexVector(t.namedVectors[r]);return new y(e,s,i)}}export{c as a,p as b,l as d,b as e,_ as f,y as r,u as s};
