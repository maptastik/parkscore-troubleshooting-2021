import{cz as e,g1 as t,g2 as n,g3 as o,m as l,z as a,eV as r,eT as s,d9 as i,d_ as c,k as u}from"./vendor.1ee57f36.js";const h=function(e,t){const n=(e.isWGS84||e.isWebMercator)&&(t.isWGS84||t.isWebMercator);return!(e.equals(t)||n)};async function x(){if(t()||!n())return null;await o()}function f(e,n,o,i=null){if(e.spatialReference.equals(n))return e;const c=h(e.spatialReference,n);if(c&&!t())throw new l("rasterprojectionhelper-projectResolution","projection engine is not loaded");const u=o.center,x=new a({xmin:u.x-e.x/2,xmax:u.x+e.x/2,ymin:u.y-e.y/2,ymax:u.y+e.y/2,spatialReference:e.spatialReference}),f=c?r(x,n,i):s(x,n);return null==f?null:{x:f.xmax-f.xmin,y:f.ymax-f.ymin}}function m(e,t=.01){return c(e)?t/c(e):0}function p(e,n,o=null,a=!0){const c=e.spatialReference;if(c.equals(n))return e;const u=h(c,n);if(u&&!t())throw new l("rasterprojectionhelper-projectResolution","projection engine is not loaded");const x=u?r(e,n,o):s(e,n);if(x&&a&&n.isGeographic){var f,p;const[t,n]=c.isWebMercator?i(c).origin:null!=(f=null==(p=i(c))?void 0:p.valid)?f:[],o=m(c);o&&null!=t&&null!=n&&(Math.abs(e.x-t)<o&&Math.abs(180-x.x)<5e-4?x.x-=360:Math.abs(e.x-n)<o&&Math.abs(180+x.x)<5e-4&&(x.x+=360))}return x}function y(n,o,a=null,c=!0){var u,x,f,y;const d=n.spatialReference;if(d.equals(o))return n;const M=h(d,o);if(M&&!t())throw new l("rasterprojectionhelper-projectExtent","projection engine is not loaded");const g=M?r(n,o,a):s(n,o);let[w,R]=null!=(u=null==(x=i(d))?void 0:x.origin)?u:[];if(g&&c&&d.isWebMercator&&o.isGeographic&&null!=w&&null!=R){const t=.001,l=1e3;if(Math.abs(n.xmin-w)<t&&Math.abs(R-n.xmax)>l&&Math.abs(180-g.xmax)<5e-4){g.xmin=-180;const t=[];t.push(new e(n.xmax,n.ymin,d)),t.push(new e(n.xmax,(n.ymin+n.ymax)/2,d)),t.push(new e(n.xmax,n.ymax,d));const l=t.map((e=>p(e,o,a))).filter((e=>!isNaN(null==e?void 0:e.x))).map((e=>e.x));g.xmax=Math.max.apply(null,l)}if(Math.abs(n.xmax-R)<t&&Math.abs(w-n.xmin)>l&&Math.abs(180+g.xmin)<5e-4){g.xmax=180;const t=[];t.push(new e(n.xmin,n.ymin,d)),t.push(new e(n.xmin,(n.ymin+n.ymax)/2,d)),t.push(new e(n.xmin,n.ymax,d));const l=t.map((e=>p(e,o,a))).filter((e=>!isNaN(null==e?void 0:e.x))).map((e=>e.x));g.xmin=Math.min.apply(null,l)}}[w,R]=o.isWebMercator?i(o).origin:null!=(f=null==(y=i(o))?void 0:y.valid)?f:[];const v=m(o);return v&&null!=w&&null!=R&&(Math.abs(g.xmin-w)<v&&(g.xmin=w),Math.abs(g.xmax-R)<v&&(g.xmax=R)),g}function d(n,o,a,r=null,s=null,c=!1,u=[32,32]){var x,f;if(h(n.spatialReference,o.spatialReference)&&!t())throw new l("rasterprojectionhelper-projectResolution","projection engine is not loaded");if(!(n&&o&&a))return null;const{xmin:m,ymin:y,xmax:d,ymax:M}=n,g=n.spatialReference,w=o.spatialReference,[R,v]=null!=(x=null==(f=i(g))?void 0:f.valid)?x:[],b={x:u[0]*a.x,y:u[1]*a.y},k={cols:Math.ceil((d-m)/b.x-.1)+1,rows:Math.ceil((M-y)/b.y-.1)+1},_=b.x,z=b.y,B=[];let j,C=!1;for(let t=0;t<k.cols;t++){const n=[];for(let l=0;l<k.rows;l++){let a=p(new e({x:m+_*t,y:M-z*l,spatialReference:g}),w,r);s&&(a=s.inverseTransform(a)),n.push(a),t>0&&c&&a&&j[l]&&null!=R&&a.x<j[l].x&&(a.x+=v-R),a?(B.push((a.x-o.xmin)/(o.xmax-o.xmin)),B.push((o.ymax-a.y)/(o.ymax-o.ymin))):(B.push(NaN),B.push(NaN),C=!0)}j=n}const N=function(e,t){const n=(e[0]+e[4]+e[4*t.cols]+e[4*t.cols+4])/4,o=(e[1]+e[5]+e[4*t.rows+1]+e[4*t.rows+5])/4;return[Math.abs(n-e[2*t.rows+2]),Math.abs(o-e[2*t.rows+3])]}(B,k),S=new Float32Array((k.cols-1)*(k.rows-1)*2*6),W=new Float32Array([-0,-1,1,-1,1,-0,1,-0,-0]),T=new Float32Array([-1,1,0,0,-1,1,1,0,0]);for(let e=0;e<k.cols-1;e++){for(let t=0;t<k.rows-1;t++){let n=e*k.rows*2+2*t;const o=B[n],l=B[n+1],a=B[n+2],r=B[n+3];n+=2*k.rows;const s=B[n],i=B[n+1],c=B[n+2],u=B[n+3];let h=0,x=12*(t*(k.cols-1)+e);for(let e=0;e<3;e++)S[x++]=W[h++]*o+W[h++]*a+W[h++]*c;h=0;for(let e=0;e<3;e++)S[x++]=W[h++]*l+W[h++]*r+W[h++]*u;h=0;for(let e=0;e<3;e++)S[x++]=T[h++]*o+T[h++]*s+T[h++]*c;h=0;for(let e=0;e<3;e++)S[x++]=T[h++]*l+T[h++]*i+T[h++]*u}if(C)for(let e=0;e<S.length;e++)isNaN(S[e])&&(S[e]=-1)}return{offsets:B,error:N,coefficients:S,spacing:u,size:[k.cols-1,k.rows-1]}}function M(t,n,o){const l=Math.log(t.x/n.pixelSize.x)/Math.LN2,a=Math.log(t.y/n.pixelSize.y)/Math.LN2,r=n.storageInfo.maximumPyramidLevel||0;let s="down"===o?Math.floor(Math.min(l,a)):"up"===o?Math.ceil(Math.max(l,a)):Math.round((l+a)/2),i=!1;s<0?s=0:s>r&&(i=s>r+3,s=r);const c=Math.pow(2,s);return{pyramidLevel:s,pyramidResolution:new e({x:c*n.nativePixelSize.x,y:c*n.nativePixelSize.y,spatialReference:n.spatialReference}),excessiveReading:i}}function g(t,n,o=512,l=!0){const{extent:a,spatialReference:r,pixelSize:s}=t,i=f(new e({x:s.x,y:s.y,spatialReference:r}),n,a);if(null==i)return{projectedPixelSize:null,scales:null,srcResolutions:null};const u=(i.x+i.y)/2,h=c(n),x=u*h*96*39.37,m=n.isGeographic?512/o*295828763.7958547:512/o*591657527.591555;let p=!1;if(l&&(n.isGeographic||n.isWebMercator)){const e=y(a,n);p=e.xmin*e.xmax<0}let d,M=x;if(p){M=m;const t=M/(96*h*39.37);d=f(new e({x:t,y:t,spatialReference:n}),r,a)}else{d={x:s.x,y:s.y};const e=Math.ceil(Math.log(Math.min(t.width,t.height)/32)/Math.LN2);let n=0;for(;M<.5005*m&&n<e;)n++,M*=2,d.x*=2,d.y*=2;Math.max(M,m)/Math.min(M,m)<=1.001&&(M=m)}const g=[],w=[],R=Math.min(70.5310735,x)/1.001;for(;M>=R;)g.push(M),w.push({x:d.x,y:d.y}),M/=2,d.x/=2,d.y/=2;return{projectedPixelSize:i,scales:g,srcResolutions:w}}const w=new Map,R=new class{constructor(e=15e3,t=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=e,this._interval=Math.min(e,t)}decreaseRefCount(e,t){const n=e+"/"+t,o=this._cachedBlocks;if(o.has(n)){const e=o.get(n);return e.refCount--,e.refCount<=0&&(o.delete(n),e.controller&&e.controller.abort()),e.refCount}return 0}getBlock(e,t){const n=e+"/"+t,o=this._cachedBlocks;if(o.has(n)){const e=o.get(n);return e.ts=Date.now(),e.refCount++,o.delete(n),o.set(n,e),e.block}return null}putBlock(e,t,n,o=null){const l=this._cachedBlocks,a=e+"/"+t;if(l.has(a)){const e=l.get(a);e.ts=Date.now(),e.refCount++}else l.set(a,{block:n,ts:Date.now(),refCount:1,controller:o});this.trim(),this.updateTimer()}deleteBlock(e,t){const n=this._cachedBlocks,o=e+"/"+t;n.has(o)&&n.delete(o)}updateMaxSize(e){this._size=e,this.trim()}empty(){this._cachedBlocks.clear(),this.clearTimer()}getCurrentSize(){return this._cachedBlocks.size}updateTimer(){if(null!=this._timer)return;const e=this._cachedBlocks;this._timer=setInterval((()=>{const t=Array.from(e),n=Date.now();for(let o=0;o<t.length&&t[o][1].ts<=n-this._duration;o++)e.delete(t[o][0]);0===e.size&&this.clearTimer()}),this._interval)}trim(){const e=this._cachedBlocks;if(-1===this._size||this._size>=e.size)return;const t=Array.from(e);for(let n=0;n<t.length-this._size;n++)e.delete(t[n][0])}clearTimer(){null!=this._timer&&(clearInterval(this._timer),this._timer=null)}};function v(e,t){return null==t?e:`${e}?sliceId=${t}`}function b(e,t){const n={extent:null,rasterInfo:t,cache:new Map};if(w.has(e)){const t=w.get(e);return t.push(n),t.length-1}return w.set(e,[n]),0}function k(e,t){w.has(e)&&(w.get(e)[t]=null)}function _(e,t,n){if(!w.has(e))return null==t?R.decreaseRefCount(e,n):0;const o=w.get(e);if(null==o[t])return R.decreaseRefCount(e,n);const l=o[t].cache;if(l.has(n)){const e=l.get(n);if(e.refCount--,0===e.refCount){l.delete(n);for(let e=0;e<o.length;e++)o[e]&&o[e].cache.has(n)&&o[e].cache.delete(n);e.controller&&e.controller.abort()}return e.refCount}return 0}function z(e,t,n){if(!w.has(e))return null==t?R.getBlock(e,n):null;const o=w.get(e);if(null==o[t]){for(let e=0;e<o.length;e++)if(o[e]&&o[e].cache.has(n)){const t=o[e].cache.get(n);return t.refCount++,t.block}return R.getBlock(e,n)}const l=o[t].cache;if(l.has(n)){const e=l.get(n);return e.refCount++,e.block}for(let a=0;a<o.length;a++)if(a!==t&&o[a]&&o[a]&&o[a].cache.has(n)){const e=o[a].cache.get(n);return e.refCount++,l.set(n,e),e.block}return null}function B(e,t,n,o,l=null){if(!w.has(e))return void(null==t&&R.putBlock(e,n,o,l));const a=w.get(e);if(null==a[t])return void R.putBlock(e,n,o,l);const r={refCount:1,block:o,isResolved:!1,isRejected:!1,controller:l};o.then((()=>r.isResolved=!0)).catch((()=>r.isRejected=!0)),a[t].cache.set(n,r)}function j(e,t,n){if(!w.has(e))return void(null==t&&R.deleteBlock(e,n));const o=w.get(e);null!=o[t]?o[t].cache.delete(n):R.deleteBlock(e,n)}function C(t,n,o,l,a,r,s=null){const i=function(e,t){if(!w.has(e))return null;const n=w.get(e);return null==n[t]?null:n[t]}(t,n),c=i.extent,{cache:h,rasterInfo:x}=i;if(c&&c.xmin===o.xmin&&c.xmax===o.xmax&&c.ymin===o.ymin&&c.ymax===o.ymax)return;const m=o.clone().normalize(),{spatialReference:p,transform:d}=x,g=new Set;for(let w=0;w<m.length;w++){const t=m[w];if(t.xmax-t.xmin<=l||t.ymax-t.ymin<=l)continue;let n=y(t,p,s);u(d)&&(n=d.inverseTransform(n));const o=new e({x:l,y:l,spatialReference:t.spatialReference});if(null===a&&!(a=f(o,p,t,s)))return;const{pyramidLevel:i,pyramidResolution:c,excessiveReading:h}=M(a,x,r||"closest");if(h)return;const{storageInfo:R}=x,{origin:v}=R,b={x:Math.max(0,Math.floor((n.xmin-v.x)/c.x)),y:Math.max(0,Math.floor((v.y-n.ymax)/c.y))},k=Math.ceil((n.xmax-n.xmin)/c.x-.1),_=Math.ceil((n.ymax-n.ymin)/c.y-.1),z=i>0?R.pyramidBlockWidth:R.blockWidth,B=i>0?R.pyramidBlockHeight:R.blockHeight,j=1,C=Math.max(0,Math.floor(b.x/z)-j),N=Math.max(0,Math.floor(b.y/B)-j),S=Math.floor((b.x+k-1)/z)+j,W=Math.floor((b.y+_-1)/B)+j;for(let e=N;e<=W;e++)for(let t=C;t<=S;t++)g.add(`${i}/${e}/${t}`)}h.forEach(((e,t)=>{if(!g.has(t)){const e=h.get(t);(null==e||e.isResolved||e.isRejected)&&h.delete(t)}})),i.extent={xmin:o.xmin,ymin:o.ymin,xmax:o.xmax,ymax:o.ymax}}export{d as M,C as a,x as b,j as c,g as d,_ as e,p as h,v as i,z as m,f as p,b as s,k as u,M as w,B as x,y};
